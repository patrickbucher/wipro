\section{Problemstellung}

TODO: einleitende Worte, Zweck dieses Kapitels

\subsection{Analyse des Projektauftrags}

TODO: hier wird die Umgebung von PEAX beschrieben

\subsubsection{Endpoints}

Eine RESTful-API besteht aus einer Reihe sogenannter \textit{Endpoints}, d.h Pfade zu Ressourcen, die abgefragt und/oder manipuliert werden können.

\subsubsection{HTTP-Methoden}

Ein Endpoint kann über eine oder mehrere HTTP-Methoden angesprochen werden \cite[Abschnitt 4.3]{RFC7231}. Im Kontext der PEAX API sind folgende Methoden relevant:

\begin{itemize}
	\item \texttt{GET}
	\item \texttt{HEAD}
	\item \texttt{POST}
	\item \texttt{PUT}
	\item \texttt{DELETE}
	\item \texttt{OPTIONS}
	\item \texttt{PATCH} \cite{RFC5789}
\end{itemize}

\subsubsection{HTTP Status-Codes}

Eine Antwort auf eine HTTP-Anfrage enthält jeweils einen Status-Code \cite[Abschnitt 6]{RFC7231}. Bei der PEAX API werden u.a. folgende Status-Codes häufig verwendet:

\begin{itemize}
	\item \texttt{200 OK}: Die Anfrage hat funktioniert.
	\item \texttt{201 Created}: Die Anfrage hat funktioniert, und dabei wurde eine neue Ressource erzeugt.
	\item \texttt{204 No Content}: Die Anfrage konnte ausgeführt werden, liefert aber keinen Inhalt zurück (etwa in einer Suche mit einem Begriff, zu dem keine Ressource gefunden werden kann).
	\item \texttt{204 Partial Content}: Der zurückgelieferte Payload repräsentiert nur einen Teil der gefundenen Informationen. Wird etwa beim Paging eingesetzt.
	\item \texttt{400 Bad Request}: Die Anfrage wurde fehlerhaft gestellt (ungültige oder fehlende Feldwerte).
	\item \texttt{401 Unauthorized}: Der Benutzer ist nicht autorisiert, d.h. nicht eingeloggt im weitesten Sinne.
	\item \texttt{403 Forbidden}: Der Benutzer ist zwar eingeloggt, hat aber keine Berechtigung mit der gewählten Methode auf die jeweilige Resource zuzugreifen.
	\item \texttt{404 Not Found}: Die Resource wurde nicht gefunden; deutet auf eine fehlerhafte URL hin.
	\item \texttt{405 Method Not Allowed}: Die Resource unterstützt die gewählte Methode nicht.
	\item \texttt{415 Unsupported Media Type}: Das Format des mitgelieferten Payloads wird nicht unterstützt. In der PEAX API sind dies etwa Dokumentformate, die beim Hochladen nicht erlaubt sind (z.B. \texttt{.exe}-Dateien).
	\item \texttt{500 Internal Server Error}: Obwohl die Anfrage korrekt formuliert und angenommen worden ist, kam es bei der Verarbeitung derselben zu einem serverseitigem Fehler.\footnote{In der PEAX API kommt es gelegentlich zu solchen Fehlern, die stattdessen mit dem Status \texttt{400 Bad Request} und einer aussagekräftigen Fehlermeldung beantwortet werden müssten. Wird z.B. bei der Einlieferung von Dokument-Metadaten eine syntaktisch fehlerhafte IBAN mitgegeben, tritt der Fehler erst bei der internen Verarbeitung, und nicht schon bei der Validierung der Anfrage auf. Hier besteht Handlungsbedarf aufseiten der Backend-Entwicklung.}
	\item \texttt{380 Unknown}: Dieser Status ist nicht Teil der HTTP-Spezifikation, wird aber nach einem Login-Versuch verwendet, wenn eine Zwei-Faktor-Authentifizierung (SMS, One Time Password) verlangt wird, und ist somit für die vorliegende Arbeit von hoher Relevanz.
\end{itemize}

\subsubsection{Umgebungen}

Bei PEAX gibt es verschiedene Umgebungen oder «Stufen», welche den ganzen PEAX-Stack (Datenbank, Backend, Frontend) für einen bestimmten Zweck zur Verfügung stellen:

\begin{description}
    \item[local] Die Entwickler können den PEAX-Stack zum Entwickeln und Testen lokal ausführen.
    \item[dev] Dies ist das Entwicklungssystem, worauf die Entwickler ihre Änderungen deployen, sobald diese vom jeweiligen Feature-Branch in den \texttt{develop}-Branch gemerged wurden. Diese Umgebung ist tendenziell sehr aktuell, aber dafür auch instabil.
    \item[test] Auf diese Stufe werden Änderungen übertragen, die auf Stufe \texttt{dev} erfolgreich getestet werden konnten. Diese Umgebung wird vom Product Owner zur Abnahme von User Stories verwendet, ist in der Regel eher stabil und repräsentiert nach jedem Sprint einen potenziell releasefähigen Stand.
    \item[stage] Diese Stufe dient für die Regressionstests. Hier wird nach jedem Sprint der letzte Stand von \texttt{test} übertragen. Bei einem Release wird der Stand von hier verwendet. Diese Umgebung ist stabil und jeweils maximal zwei Wochen alt.
    \item[prod] Von \texttt{stage} werden die Änderungen mehrmals pro Jahr (Ziel: einmal pro Monat) auf die Produktivumgebung übertragen. Dies ist die einzige Umgebung, auf der produktive Kundendaten abgelegt werden. Datenschutz und Sicherheit spielen auf dieser Umgebung eine besonders hohe Rolle.
    \item[devpatch] Dies ist die Entwicklungsumgebung für den Hotfix-Pfad. Nach einem Release wird der aktuelle Stand von \texttt{prod} auf diese Stufe deployed. Bis zum nächsten Release können hier dringende Fehlerkorrekturen vorgenommen werden.
    \item[testpatch] Dies ist die Testumgebung für den Hotfix-Pfad. Dringende Fehlerkorrekturen werden von \texttt{devpatch} auf diese Stufe übernommen und hier abgenommen. Die Änderungen werden von hier aus direkt auf \texttt{prod} deployed.
    \item[prototype] Hierbei handelt es sich um eine Umgebung, die sporadisch für Prototypen und Demos verwendet wird.
    \item[perf] Diese Umgebung wurde vor dem grossen v3-Release im Frühling für Performance-Tests verwendet und ist seither nur sporadisch in Betrieb.
\end{description}

\subsubsection{Arten von Parametern}

TODO: Query-Parameter, Header-Parameter

\subsubsection{Benutzer}

TODO Programmierer, andere?

\subsubsection{Betriebssysteme}

TODO: macOS, Windows, Linux

\subsubsection{Shells} 

TODO: sh, zsh, dash, Bash, PowerShell, CMD.EXE

\subsection{Ausgangslage und Vorleistungen}

Das Projekt \texttt{px} wurde bereits am 11. Juni 2019 auf dem GitLab von PEAX erstellt\footnote{\url{https://gitlab.peax.ch/peax3/px}}. Als erstes wurde eine CI-Pipeline bestehend aus den Schritten `build` und `test` erstellt. Die Pipeline wurde mittels eines Dummy-Tests überprüft, der einmal erfolgreich durchlaufen und einmal scheitern sollte, um einen Positiv- und einen Negativtest durchführen zu können.

Es wurde eine Hallo-Welt-Programm im \texttt{cmd}-Unterverzeichnis \cite[p. 293]{gopl} erstellt, welches dazu diente, die Kompilierung für verschiedene Plattformen zu testen. Obwohl Go-Programme mittels `go build` kompiliert werden können und keine weitere Build-Konfiguration benötigen, wurde ein \texttt{Makefile} erstellt, das ausführbare Programme für verschiedene Plattformen im \texttt{build}-Unterverzeichnis erstellt, also z.B. \texttt{build/windows/px.exe} für Windows oder \texttt{build/linux/px} für Linux.

Das \texttt{Makefile} wurde später um ein \texttt{release}-Target erweitert, womit die kompilierten Artefakte jeweils in eine Zip-Datei verpackt werden, die den aktuellen Versionstag (z.B. \texttt{v0.0.3}\footnote{\url{https://semver.org/}}) im Dateinamen enthält.

Das Target \texttt{coverage} führt die Testfälle durch, misst die Testabdeckung und generiert eine HTML-Ausgabe des getesteten Codes. Rote Zeilen sind nicht durch einen Testfall abgedeckt, grüne Zeilen hingegen schon. \cite[Kapitel 11.3]{gopl}

Weiter sind bis am 31. Juli 2019 folgende Features implementiert worden:

\begin{description}
	\item[\texttt{px help}] zeigt eine einfache Hilfeseite auf der Kommandozeile an.
    \item[\texttt{px login}] führt einen Loginversuch mit den angegebenen Credentials durch. Benutzername und Passwort können entweder als Kommandozeilenparameter oder mittels interaktiver Eingabe (\texttt{stdin}) entgegengenommen werden. Im letzteren Fall wird das eingegebene Passwort nicht angezeigt, was mit einem externen SSH-Ter\-mi\-nal-Modul\footnote{\url{https://godoc.org/golang.org/x/crypto/ssh/terminal\#Terminal.ReadPassword}} erreicht wird. Bei einem erfolgreichen Login-Versuch werden \texttt{access\_token} und \texttt{refresh\_token} aus dem Response-Payload gelesen und im \texttt{\$HOME}-Verzeichnis des jeweiligen Betriebssystem-Benutzers in eine JSON-Datei namens \texttt{.px-tokens} abgespeichert.
	\item[\texttt{px logout}] löscht ein Token-Paar für eine bestimmte Umgebung. Pro Umgebung kann es zu jedem Zeitpunkt nur ein aktives «Login», d.h. Token-Paar geben. Es besteht auch die Möglichkeit, sämtliche Tokens auf einmal zu löschen. Hierbei wird \texttt{\$HOME/.px-tokens} nicht gelöscht, sondern nur das Property \texttt{tokens} geleert. (Die Datei enthält ein Initialisierungsdatum, das nicht verlorengehen soll.)
	\item[\texttt{px upload}] lädt eine Datei (z.B. PDF) auf das PEAX-Portal hoch. Diese Funktionalität wurde eingebaut, um die Funktionsweise von \texttt{px} vor dem Ideation-Gremium zu demonstrieren\footnote{Die hochgeladene Datei erschien Sekunden später im Web-Portal, was die Anwesenden von der Funktionsweise überzeugte}.
\end{description}

Für die Evaluierung des Prototypen werden zudem die Anzahl Aufrufe und das Datum des letzten Aufrufs von \texttt{px} in eine JSON-Datei \texttt{\$HOME/.px-usage} geschrieben.

Insgesamt wurden ca. 20 Arbeitsstunden in den Prototyp investiert. Ein grosser Teil des Codes kann für die Weiterentwicklung übernommen werden, muss jedoch umstrukturiert werden. So ist zuviel Logik im Hauptmodul \texttt{cmd/px.go}, die zwecks Wiederverwendbarkeit in das Library-Modul \texttt{px} überführt werden soll.

\subsection{Risikoanalyse}

TODO:

Projektrisiko: fehlende Adaption, Grösse der API

Sicherheitsrisiko: Payment-Schnittstelle, Token-Verwahrung

technisches Risiko: fehlende Usability, Implementierung scheitert
